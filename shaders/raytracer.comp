#version 430

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct HitPayload {
    float hitDistance;
    vec3 position;
    vec3 normal;
    int materialIndex;
};

struct Material {
    vec3 albedo;
    float roughness;
    float metallic;
    vec3 emissionColor;
    float emissionPower;
};

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D colorbuffer;
layout(std430, binding = 1) readonly buffer sceneData{
    int[] voxelGrid;
};
uniform ivec3 gridSize;

uniform vec3 cameraPosition;
uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;
uniform int rendererRandom;
uniform int maxAccumulations;

const int bounces = 5;
const vec3 backgroundColor = vec3(0.6, 0.7, 0.9);
const float M_PI = 3.14159265358979323846;

const Material[] materials = {
    Material(vec3(0,0,0), 0, 0, vec3(1), 0),
    Material(vec3(0.7,0.4,0), 0.98, 0, vec3(1,0,0), 0),
    Material(vec3(0,0.7,0.1), 0.97, 0, vec3(0,1,0), 0),
    Material(vec3(0,0.2,0.7), 0.99, 0, vec3(0,0,1), 0),
};


// Utility function to calculate intersection with grid boundaries
bool intersectGridBounds(Ray ray, out ivec3 voxelPosition, out float tEntry, out vec3 normal) {

    vec3 step = sign(ray.direction);

    vec3 tMin = (vec3(0.0) - ray.origin) / ray.direction;
    vec3 tMax = (vec3(gridSize) - ray.origin) / ray.direction;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    tEntry = max(max(t1.x, t1.y), t1.z);

    if(tEntry == t1.x){
        normal = vec3(-step.x, 0, 0);
    } else if(tEntry == t1.y){
        normal = vec3(0, -step.y, 0);
    } else{
        normal = vec3(0, 0, -step.z);
    }

    float tExit = min(min(t2.x, t2.y), t2.z);

    if (tEntry > tExit) {
        return false; // No intersection with grid
    }

    if (tEntry < 0){
        return false;
    }

    vec3 intersectionPoint = ray.origin + ray.direction * tEntry;

    const float epsilon = 1e-4;
    intersectionPoint += epsilon * normalize(ray.direction);

    voxelPosition = ivec3(floor(intersectionPoint));

    return true;
}

HitPayload traceRay(Ray ray) {
    HitPayload hitPayload;
    hitPayload.hitDistance = 0.0;
    hitPayload.normal = vec3(0.0);
    hitPayload.materialIndex = 0;

    ivec3 voxelPosition;
    float t = 0;
    vec3 normal = vec3(0);

    vec3 invDir = 1.0 / ray.direction;
    ivec3 stepInGrid = ivec3(sign(ray.direction));

    // If the ray starts inside the grid, use the original ray origin
    if (!(ray.origin.x < 0.0 || ray.origin.x >= float(gridSize.x) ||
    ray.origin.y < 0.0 || ray.origin.y >= float(gridSize.y) ||
    ray.origin.z < 0.0 || ray.origin.z >= float(gridSize.z))) {
        voxelPosition = ivec3(floor(ray.origin));
    }

    // If it is outside check if it will intersect the grid or not
    else{
        if (!intersectGridBounds(ray, voxelPosition, t, normal)){
            hitPayload.hitDistance = -1;
            return hitPayload;
        }

    }

    // Calculate tMax and tDelta
    vec3 tMax = (vec3(voxelPosition + stepInGrid*0.5 + 0.5) - ray.origin) * invDir;
    vec3 tDelta = abs(invDir);

    int i = 0;

    while (i<10000) {
        i++;

        // Check if the current voxel is out of the grid bounds
        if (voxelPosition.x < 0 || voxelPosition.x >= gridSize.x ||
        voxelPosition.y < 0 || voxelPosition.y >= gridSize.y ||
        voxelPosition.z < 0 || voxelPosition.z >= gridSize.z) {
            hitPayload.hitDistance = -1;
            return hitPayload;
        }

        // Check if the current voxel is a block
        if (voxelGrid[voxelPosition.x + voxelPosition.z * gridSize.x + voxelPosition.y * gridSize.x * gridSize.z] != 0) {
            hitPayload.materialIndex = voxelGrid[voxelPosition.x + voxelPosition.z * gridSize.x + voxelPosition.y * gridSize.x * gridSize.z];
            hitPayload.hitDistance = t;
            hitPayload.normal = normal;
            hitPayload.position = ray.direction * t + ray.origin;
            return hitPayload; // Hit
        }

        // Traverse the grid
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                voxelPosition.x += stepInGrid.x;
                t = tMax.x;
                normal = vec3(-stepInGrid.x, 0, 0);
                tMax.x += tDelta.x;
            } else {
                voxelPosition.z += stepInGrid.z;
                t = tMax.z;
                normal = vec3(0, 0, -stepInGrid.z);
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                voxelPosition.y += stepInGrid.y;
                t = tMax.y;
                normal = vec3(0, -stepInGrid.y, 0);
                tMax.y += tDelta.y;
            } else {
                voxelPosition.z += stepInGrid.z;
                t = tMax.z;
                normal = vec3(0, 0, -stepInGrid.z);
                tMax.z += tDelta.z;
            }
        }

    }

    hitPayload.hitDistance = -1;
    return hitPayload;
}

uint PCGHash(uint input)
{
    uint state = input * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float randFloat(inout uint seed){
    seed = PCGHash(seed);
    return float(seed)/float(0xFFFFFFFFu);
}

vec3 randSphere(inout uint seed){
    return normalize(vec3(
        2*(randFloat(seed) - 0.5),
        2*(randFloat(seed) - 0.5),
        2*(randFloat(seed) - 0.5)
    ));

}

vec3 randHemisphere(inout uint seed, vec3 normal){
    vec3 v = randSphere(seed);
    return v * sign(dot(v, normal));
}

void main() {

    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(colorbuffer);
    if (pixelPos.x >= screen_size.x || pixelPos.y >= screen_size.y) {
        return;
    }

    uint seed = uint((pixelPos.x<<16) + (pixelPos.y) + rendererRandom);

    Ray ray;

    vec2 coord = vec2( float(pixelPos.x) / float(screen_size.x), float(pixelPos.y) / float(screen_size.y));
    coord = coord * 2 - 1;

    vec4 target = inverseProjectionMatrix * vec4(coord.x, coord.y, 1, 1);
    vec3 cameraRayDirection = normalize(vec3(inverseViewMatrix * vec4(normalize(vec3(target) / target.w), 0)));

    ray.origin = cameraPosition;
    ray.direction = cameraRayDirection;
    HitPayload hitPayload;
    Material material;

    vec3 light = vec3(0);
    vec3 contribution = vec3(1);

    for (int j = 0; j < bounces; j++){
        seed += j;
        hitPayload = traceRay(ray);

        if (hitPayload.hitDistance < 0) {
            light += backgroundColor * contribution;
            break;
        }

        material = materials[hitPayload.materialIndex];

        contribution *= material.albedo;
        light += material.emissionColor*material.emissionPower;

        ray.origin = hitPayload.position + hitPayload.normal * 0.001;

        float diffuse = randFloat(seed);
        if(material.roughness >= diffuse){
            ray.direction = randHemisphere(seed, hitPayload.normal);
        }
        else
            ray.direction = reflect(ray.direction, hitPayload.normal);
    }


    imageStore(colorbuffer, pixelPos, vec4(light, 1.0));
}
