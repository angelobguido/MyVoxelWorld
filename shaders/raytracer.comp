#version 430

struct Ray {
    vec3 origin;
    vec3 direction;
};

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D colorbuffer;
layout(std430, binding = 1) readonly buffer sceneData{
    int[] voxelGrid;
};
uniform ivec3 gridSize;

uniform vec3 cameraPosition;
uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;

const vec3 sunDirection = normalize(vec3(0.5, 1, -1.0));

const vec3[] blockTypes = {
    vec3(0,0,0),
    vec3(1,0,0),
    vec3(0,1,0),
    vec3(0,0,1)
};

// Utility function to calculate intersection with grid boundaries
bool intersectGridBounds(Ray ray, out ivec3 voxelPosition, out float tEntry, inout vec3 normal) {

    vec3 step = sign(ray.direction);

    vec3 tMin = (vec3(0.0) - ray.origin) / ray.direction;
    vec3 tMax = (vec3(gridSize) - ray.origin) / ray.direction;

    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);

    tEntry = max(max(t1.x, t1.y), t1.z);

    if(tEntry == t1.x){
        normal = vec3(-step.x, 0, 0);
    } else if(tEntry == t1.y){
        normal = vec3(0, -step.y, 0);
    } else{
        normal = vec3(0, 0, -step.z);
    }

    float tExit = min(min(t2.x, t2.y), t2.z);

    if (tEntry > tExit) {
        return false; // No intersection with grid
    }

    if (tEntry < 0){
        return false;
    }

    // Calculate the intersection point
    vec3 intersectionPoint = ray.origin + ray.direction * tEntry;

    // Adjust for precision issues by adding a small epsilon
    const float epsilon = 1e-4;
    intersectionPoint += epsilon * normalize(ray.direction);

    // Calculate the voxel position
    voxelPosition = ivec3(floor(intersectionPoint));

    // Ensure that the voxel position is within the grid bounds
//    voxelPosition = clamp(voxelPosition, ivec3(0), gridSize - 1);

    return true;
}


bool hit(Ray ray, inout float t, inout vec3 normal, out ivec3 voxelPosition) {
    t = 0.0;
    normal = vec3(0.0);

    // Initialize ray parameters
    vec3 invDir = 1.0 / ray.direction;
    ivec3 stepInGrid = ivec3(sign(ray.direction));

    // If the ray starts inside the grid, use the original ray origin
    if (!(ray.origin.x < 0.0 || ray.origin.x >= float(gridSize.x) ||
    ray.origin.y < 0.0 || ray.origin.y >= float(gridSize.y) ||
    ray.origin.z < 0.0 || ray.origin.z >= float(gridSize.z))) {
        voxelPosition = ivec3(floor(ray.origin));
        normal = vec3(0);
    }

    // If it is outside check if it will intersect the grid or not
    else{
        if (!intersectGridBounds(ray, voxelPosition, t, normal))
            return false;

    }

    // Calculate tMax and tDelta
    vec3 tMax = (vec3(voxelPosition + stepInGrid*0.5 + 0.5) - ray.origin) * invDir;
    vec3 tDelta = abs(invDir);

    int i = 0;

    while (i<10000) {
        i++;

        // Check if the current voxel is out of the grid bounds
        if (voxelPosition.x < 0 || voxelPosition.x >= gridSize.x ||
        voxelPosition.y < 0 || voxelPosition.y >= gridSize.y ||
        voxelPosition.z < 0 || voxelPosition.z >= gridSize.z) {
            return false; // No hit
        }

        // Check if the current voxel is a block (1)
        if (voxelGrid[voxelPosition.x + voxelPosition.z * gridSize.x + voxelPosition.y * gridSize.x * gridSize.z] != 0) {
           return true; // Hit
        }

        // Traverse the grid
        if (tMax.x < tMax.y) {
            if (tMax.x < tMax.z) {
                voxelPosition.x += stepInGrid.x;
                t = tMax.x;
                normal = vec3(-stepInGrid.x, 0, 0);
                tMax.x += tDelta.x;
            } else {
                voxelPosition.z += stepInGrid.z;
                t = tMax.z;
                normal = vec3(0, 0, -stepInGrid.z);
                tMax.z += tDelta.z;
            }
        } else {
            if (tMax.y < tMax.z) {
                voxelPosition.y += stepInGrid.y;
                t = tMax.y;
                normal = vec3(0, -stepInGrid.y, 0);
                tMax.y += tDelta.y;
            } else {
                voxelPosition.z += stepInGrid.z;
                t = tMax.z;
                normal = vec3(0, 0, -stepInGrid.z);
                tMax.z += tDelta.z;
            }
        }

    }

    return false; // No hit
}

void main() {

    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screen_size = imageSize(colorbuffer);
    if (pixelPos.x >= screen_size.x || pixelPos.y >= screen_size.y) {
        return;
    }

    Ray ray;
    ray.origin = cameraPosition;

    vec2 coord = vec2( float(pixelPos.x) / float(screen_size.x), float(pixelPos.y) / float(screen_size.y));
    coord = coord * 2 - 1;

    vec4 target = inverseProjectionMatrix * vec4(coord.x, coord.y, 1, 1);
    ray.direction = normalize(vec3(inverseViewMatrix * vec4(normalize(vec3(target) / target.w), 0)));

    float t = 0;

    vec3 color = vec3(0);
    vec3 normal;

    ivec3 voxelPosition;

    if (hit(ray, t, normal, voxelPosition)) {
        float light_amount = max(0.0, dot(-ray.direction, normal));
        color = light_amount * blockTypes[voxelGrid[voxelPosition.x + voxelPosition.z * gridSize.x + voxelPosition.y * gridSize.x * gridSize.z]];
    }


//
//    ivec3 testStep = ivec3(sign(ray.direction));
//
//    if(testStep.z == 1){
//        color = vec3(0,0,1);
//    }

    imageStore(colorbuffer, pixelPos, vec4(color, 1.0));
}
